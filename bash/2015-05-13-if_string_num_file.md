# if 字符 数字 判断
参数个数判断

    if [[ $# -eq 0 ]];then
    fi
## test和三种比较操作符
内置命令 test 根据表达式expr 求值的结果返回 0（真）或 1（假）。也可以使用方括号：test expr 和 [ expr ] 是等价的。 可以用 $? 检查返回值；可以使用 && 和 || 操作返回值；也可以用本技巧后面介绍的各种条件结构测试返回值。
`[ ... ]` 传统操作  
`[[ ... ]]` 加强型操作  
`(( ... ))` 数字专用，可以用 C 语言类似的比较操作符  
    `if (( $num <= 5 )); then`

## 比较操作符在双中括号对和单中括号对中的行为是不同的.
双括号语法　`[[ ... ]]`是单括号语法`[ ... ]`的加强型，但它们还有几点不同
1. 双括号支持通配符  
     `[[ $a == z* ]]`    # 如果$a以"z"开头(模式匹配)那么结果将为真  
     `[ $a == "z*" ]`  # 如果$a与z*相等(就是字面意思完全一样), 那么结果为真.
     `if [[ “$stringvar” == *[sS]tring* ]]; then` 匹配　string 和 String
     *只支持基本的shell通配符，如果右边用引号包围的话，则是普通字面字符* 
2. 双括号中单词分割被禁止了，变量的值中有空格也会被作为一个整体看待．  
3. 双括号不扩展文件名  
 `if [ -a *.sh ]; then` 有且只有一个`.sh`后缀的文件时返回true, 没有返回false,有多个则脚本报错．　　
 `if [[ -a *.sh ]]; then` 必须有一个文件名叫`*.sh` 才会返回true,其它情况都是false  
4. 双括号支持　`&& ||`  
`if [[ $num -eq 3 && “$stringvar” == foo ]]; then`
5. 双括号支持正则，操作符`=~`
```
if [[ "$email" =~ "b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,4}b" ]]; then
    echo "$email contains a valid e-mail address."
fi 
```    
## 整数比较

-eq 等于 `if [ "$a" -eq "$b" ]`
-ne 不等于 `if [ "$a" -ne "$b" ]`
-gt 大于 `if [ "$a" -gt "$b" ]`
-ge 大于等于 `if [ "$a" -ge "$b" ]`
-lt 小于 `if [ "$a" -lt "$b" ]`
-le 小于等于 `if [ "$a" -le "$b" ]`

`<` 小于(在双括号中使用) `(("$a" < "$b"))`
`<=` 小于等于(在双括号中使用) `(("$a" <= "$b"))`
`>` 大于(在双括号中使用) `(("$a" > "$b"))`
`>=` 大于等于(在双括号中使用) `(("$a" >= "$b"))`

## 多个条件连接
`and  -a     or -o`

`if [ $num -gt 0 -a $num -lt 5 ];then ...` if(num > 0 and num < 5)

## 字符串比较

`=` 等于 `if [ "$a" = "$b" ]`  
`==` 等于 `if [ "$a" == "$b" ]` 与`=`等价.
`!=` 不等号 `if [ "$a" != "$b" ]` 这个操作符将在[[ ... ]]结构中使用模式匹配. 
`<` 小于, 按照ASCII字符进行排序 `if [[ "$a" < "$b" ]]` `if [ "$a" \< "$b" ]` 
*注意 `"<"` 使用在[ ]结构中的时候需要被转义.*
    
`>` 大于, 按照ASCII字符进行排序 `if [[ "$a" > "$b" ]]` `if [ "$a" \> "$b" ]` 
*注意`">"`使用在[ ]结构中的时候需要被转义.*

`-z` 字符串为"null", 意思就是字符串长度为零
`-n` 字符串不为"null".

*Caution*

当-n使用在中括号中进行条件测试的时候, 必须要把字符串用双引号引用起来. 如果采用了未引用的字符串来使用! -z, 甚至是在条件测试中括号(参见例子 7-6)中只使用未引用的字符串的话, 一般也是可以工作的, 然而, 这是一种不安全的习惯. 习惯于使用引用的测试字符串才是正路. [1] 

## if 文件判断

`-e` 文件存在  
`-a` 文件存在, 这个选项的效果与-e相同. 但是它已经被"弃用"了, 并且不鼓励使用.  
`-f` 表示这个文件是一个一般文件(并不是目录或者设备文件)  
`-s` 文件大小不为零  
`-d` 表示这是一个目录  
`-b` 表示这是一个块设备(软盘, 光驱, 等等.)   
`-c` 表示这是一个字符设备(键盘, modem, 声卡, 等等.)  
`-p` 这个文件是一个管道  
`-h` 这是一个符号链接  
`-L` 这是一个符号链接  
`-S` 表示这是一个socket  
`-t` 文件(描述符)被关联到一个终端设备上  
    这个测试选项一般被用来检测脚本中的stdin([ -t 0 ]) 或者stdout([ -t 1 ])是否来自于一个终端.   
`-r` 文件是否具有可读权限(指的是正在运行这个测试命令的用户是否具有读权限)  
`-w` 文件是否具有可写权限(指的是正在运行这个测试命令的用户是否具有写权限)  
`-x` 文件是否具有可执行权限(指的是正在运行这个测试命令的用户是否具有可执行权限)  
`-g` set-group-id(sgid)标记被设置到文件或目录上  
    如果目录具有sgid标记的话, 那么在这个目录下所创建的文件将属于拥有这个目录的用户组, 而不必是创建这个文件的用户组. 这个特性对于在一个工作组中共享目录非常有用. 
`-u` set-user-id (suid)标记被设置到文件上  
    如果一个root用户所拥有的二进制可执行文件设置了set-user-id标记位的话, 那么普通用户也会以root权限来运行这个文件. [1] 这对于需要访问系统硬件的执行程序(比如pppd和cdrecord)非常有用. 如果没有suid标志的话, 这些二进制执行程序是不能够被非root用户调用的.` -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd`
    对于设置了suid标志的文件, 在它的权限列中将会以s表示.   
`-k` 设置粘贴位  
    对于"粘贴位"的一般了解, save-text-mode标志是一个文件权限的特殊类型. 如果文件设置了这个标志, 那么这个文件将会被保存到缓存中, 这样可以提高访问速度. [2] 粘贴位如果设置在目录中, 那么它将限制写权限. 对于设置了粘贴位的文件或目录, 在它们的权限标记列中将会显示t.` drwxrwxrwt    7 root         1024 May 19 21:26 tmp/`
    如果用户并不拥有这个设置了粘贴位的目录, 但是他在这个目录下具有写权限, 那么这个用户只能在这个目录下删除自己所拥有的文件. 这将有效的防止用户在一个公共目录中不慎覆盖或者删除别人的文件. 比如说/tmp目录. (当然, 目录的所有者或者root用户可以随意删除或重命名其中的文件.)   
`-O` 判断你是否是文件的拥有者  
`-G` 文件的group-id是否与你的相同  
`-N` 从文件上一次被读取到现在为止, 文件是否被修改过  
`f1 -nt f2` 文件f1比文件f2新  
`f1 -ot f2` 文件f1比文件f2旧  
`f1 -ef f2` 文件f1和文件f2是相同文件的硬链接  
`!` "非" -- 反转上边所有测试的结果(如果没给出条件, 那么返回真).  

refs:  
[Conditions in bash scripting (if statements)](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/)  
[Linux 技巧: Bash 测试和比较函数](https://www.ibm.com/developerworks/cn/linux/l-bash-test.html)  


