# java 内存模型
JMM java memory model  
## 基础

*并发模型的分类*
内存共享  消息传递  
显式同步  隐式同步  
隐式消息传递 显式消息传递  

*java内存模型的抽象*
共享的主内存   和  各个线程的本地内存  

*重排序*
编译器优化重排序  
指令级重排序   处理器进行  java 会插入内存屏障  memory barriers,intel 称之为 memory fence  
内存重排序  

*处理器重排序与内存屏障指令*
内存屏障的四种类型:  LoadLoad  StoreStore  LoadStore  StoreLoad  

与程序员密切相关的 happens-before 规则:程序顺序规则  监视器锁规则 volatile规则 传递性  

## 重排序
*数据依赖性*
重排了会改变程序结果的程序顺序  
*as-if-serial语义* 是指不管如何重排序,单线程程序的执行结果不能被改变,所有重排都要遵守as-if-serial  
*重排序对多线程的影响* 
重排序不会影响单线程程序的结果, 但是可能会改变多线程程序的结果  

## 顺序一致性
*数据竞争与顺序一致性保证*
当程序未正确同步时,就会产生数据竞争. (即一个写,一个读,写和读未通过同步来排序)  
一个正确同步的了的多线程程序是不存在数据竞争的  
JMM 保证了做了正确同步的程序,程序的执行将具有顺序一致性  

*顺序一致性的内存模型*
一致性内存模型的两大特性:1 线程中所有操作按照程序顺序执行 2 线程只能看到单一的操作执行顺序,每个操作都是原子的并对所有线程可见  
JMM 不保证所有线程看到相同的执行顺序,各个线程看到的可能不一样   
*未同步程序的执行特性*
JMM 对未同步的程序只作最小安全性的保障,一个线程读入的内存值要么是别的线程写入的值,要么是默认值,不会有无中生有的值.  

## volatile
*volatile的特性*
volatile只保证对一个变量的读写操作是原子的,加锁同步的,并立即对其它线程可见  
volatile++这种操作属于复合操作, 不具有原子性  

*volatile 写-读的内存语义*
volatile写的内存语义: 当写一个volatile变量时,JMM会把该线程本地内存中的共享变量值刷新到主内存  
volatile读的内存语义: 当读一个volatile变量时,JMM会从主内存中重新读取共享变量,刷新线程本地内存中的所有共享变量  

*volatile内存语义的实现* 
插入内存屏障, 因为典型场景是一个线程写,多个线程读,所以StoreLoad放在所有写的后面,没放在所有读的前面  
StoreStore  
volatile 写  
StoreLoad  


volatile 读  
LoadLoad  
LoadStore  

## 锁
*锁释放和获取的内存语义* 根volatile的读写类似  
释放锁的内存语义: 释放锁时,JMM会把线程本地的共享变量值刷新到主内存中   
获取锁的内存语义: 获取锁时,JMM会从主内存中读取所有共享变量的值,刷新本地内存   

*锁内存的语义实现*  
至少有两种方式可以实现  
1. 利用volatile读和写所具有的内存语义  
2. 利用CAS(compareAndSet)同时有volatile读和写的内存语义  

*concurrent包的实现*  
1. 声明共享变量是volatile  
2. 利用CAS实现进程间的同步
3. 利用volatile的读写和CAS更新实现进程间的通信

## final
final域的重排序规则  
1. 构造函数中对final域赋值与随后的构造出的对象赋值给引用,不能进行重排序  
2. 初次读取一个包含final字段对象的引用,与初次读取这个final字段的引用, 不能重排序 




















