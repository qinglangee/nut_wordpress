# c++ 参数与返回值中的 对象 引用 和 指针
所有C++权威的书上都要求“一定不要返回局部对象或变量的引用和指针”

## 返回对象和返回引用
[C++返回对象和返回引用][1]  

函数原型
Car run(const Car &)     //返回对象
Car &run(const Car &)   //返回引用
```
RMB& RMB::operator++()  
{  
    yuan++;  
    return *this;  
}  
RMB RMB::operator++(int)  
{  
    RMB temp(yuan);      //创建对象  
    yuan++;  
    return temp;          //返回对象的副本  
}  
```
通用的规则是，如果函数返回在函数中创建的临时对象，则不要使用引用，如果先创建一个对象，然后返回改对象的副本，则可以使用返回对象，如上述第二种情况。

如果函数返回的是通过引用或指针传递给它的对象，则应当按引用返回对象。当按引用返回调用函数的对象或作为参数传递给函数的对象。如上面的第一种情况。  

C++返回引用类型
`A& a(){ return *this;}` 就生成了一个固定地址的指针，并把指针带给你

但`A a() { return *this;}`会生成一个临时对象变量，并把这个临时变量给你
这样就多了一步操作

## 指针与引用  [c++返回对象的指针或引用有什么区别][2]
C++里引用其实只是受限的指针，只是在语义上限制不能对引用这一受限的指针做一些指针能做的操作：重新赋值，拷贝，++，--（暂时还没有想到其他的），并限制不允许为空，以提高安全性，可以理解为是编译器对指针的一种保护模式。

考虑什么时候应该使用引用，又什么时候应该使用指针呢？我认为有几点：

引用优先
凡是能用引用代替指针的都用引用。  指针是允许为空的，而引用不允许。  
容器中不可保存引用，只能用指针（我猜主要是因为引用被限制了重新赋值及拷贝操作）。
最后，随时可以把引用转化为指针。











refs:  
[C++返回对象和返回引用](https://blog.csdn.net/recording_gjl/article/details/78917605)  



[1]: https://blog.csdn.net/recording_gjl/article/details/78917605
[2]: https://www.imooc.com/wenda/detail/546007 